# 柱形图中最大的矩形

> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。

## 解题思路

任意一个矩形的面积由三个值决定，左侧位置，右侧位置，以及最矮柱子的高度，为了求得最大面积，最大面积一定要**存在遍历的所有可能性**之中。

如果对位置进行遍历，则以`1~n`每个位置作为起点，选择宽度`1~n`的矩阵，依次求面积，其中最大值就是答案。

如果对高度进行遍历，那么就是**遍历每一根柱子作为最矮柱子**的情况，先求该情况下所能得到的最大值，再把所有最大值进行比较，得出答案。

很明显，对高度进行遍历是较好的选择。

在确定了当前柱子的高度后，就需要确定左右的边界位置，**已知当前柱子是决定高度的最矮柱子，那么其它柱子都应该比它高**，所以向左右延伸，遇到比它矮的柱子就是边界。

在对柱子进行遍历的过程中，左半边柱子的高度其实已经遍历过了，如果能记录下来需要的数据，那么就可以直接取出来作为边界位置，而不需要一步一步向左移动。

要记录的数据应当**是有可能作为左边界的柱子**，是呈下降趋势的值，即该柱子的高度比左边柱子的高度要小，在不知道右边柱子的情况下，如果右边柱子都比它高，那么它**就有可能作为一个左边界**，所以要记录下来，同时，还要从数据中去除左边那些比它高的柱子，因为这些柱子都没有可能成为左边界。所以，数据结构为一个**单调递增**的栈。

同理，从右边再对数据遍历一次就可以得到记录右边界的栈。

在遍历的同时，就可以求得**每根柱子作为最矮柱子时的左右边界**，将该柱子的高度与栈中已有的柱子高度进行比较，如果比该柱子高，就出栈，直到找到第一个比该柱子矮的作为左边界，然后把**当前柱子存入栈中**。如果栈为空，说明左边的柱子里没有比当前柱子更矮的，将左边界设为`-1`，右边也是同理。

再进一步优化，因为**栈中的柱子只有遇到比自己矮的柱子的时候才会出栈**，那么说明使它出栈的那个柱子就是它的右边界，那么只要在出栈的同时，把出栈柱子的右边界设为当前柱子，这样只需要从左到右的一次遍历。

## 代码

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] left = new int[heights.length];
        int[] right = new int[heights.length];
        Arrays.fill(right,heights.length);
        Deque<Integer> stack = new LinkedList<>();
        for(int i=0;i<heights.length;i++){
            while(!stack.isEmpty() && heights[stack.peek()]>=heights[i]){
                right[stack.pop()]=i;
            }
            left[i] = stack.isEmpty()?-1:stack.peek();
            stack.push(i);
        }
        int ans = 0;
        for(int i=0;i<heights.length;i++){
            ans = Math.max(ans,(right[i]-left[i]-1) * heights[i]);
        }
        return ans;
    }
}
```



