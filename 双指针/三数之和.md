# 三数之和
> 给你一个包含 *n* 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =*0 ？请你找出所有满足条件且不重复的三元组。  
> **注意：**答案中不可以包含重复的三元组。  

之前我们已经做了两数之和，其实就可以用在这道题上。我们对数组中的每一个值进行遍历，然后将它的负数作为target送入两数之和的函数中，寻找出相对应的另外两个数。
但这样也会有几个问题：

1. 需要求出所有满足条件的三元组，那么`twoSum`的复杂度就要达到O(nlogn),再加上对原数组的遍历，复杂度过高。
2. 需要解决避免重复的问题。
所以我们在这里使用了新的算法，利用双指针来解决。因为这道题只需要求值，不需要索引，我们就可以对数组先进行排序，接着同样是从头到尾对数组进行遍历，先确定三个数中的一个，而剩下的两个数，由双指针从两端向中间压缩。若三数之和太大，则右指针向左移，正好等于0就`append`到输出数组上，否则左指针向右移。
上述是算法的基础思想，我们还要加上一些优化细节：
1. 当遍历到`nums[i]`的值大于0的时候，就不需要再往下遍历了，因为之后的数都比`nums[i]`大，则相加一定大于0
2. 不论是`i`指针还是左右指针，遇到重复的数都要跳过，这样就避免出现重复的三元组。
最终得到代码如下：

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if not nums or len(nums) < 3:
            return []
        nums.sort()
        res = []
        i = 0
        while i < len(nums):
            if nums[i] > 0:
                return res
            if i > 0 and nums[i] == nums[i-1]:
                i += 1
                continue
            l = i + 1
            r = len(nums) - 1
            while l < r:
                if nums[i] + nums[l] + nums[r] == 0:
                    res.append([nums[i],nums[l],nums[r]])
                    l += 1
                    r -= 1
                    while(l<r and nums[l] == nums[l-1]):
                        l += 1
                    while(l<r and nums[r] == nums[r+1]):
                        r -= 1
                elif nums[i] + nums[l] + nums[r] < 0:
                    l += 1
                else:
                    r -= 1
            i += 1
        return res
```
还有一个可以优化的小地方，因为寻找的是三元组，所以`i`只需要遍历到`len[nums]-2`的位置就可以了。

**bug记录**：
	一开始在`i`循环中避免重复时，使用的代码为：
```
if nums[i] == nums[i-1]:
		i += 1
     	continue
```
没有加上`i>0`的限制条件，当`i=0`的时候，`nums[-1]`指向的就是数组的最后一个数，当输入为`[0,0,0]`时，恰好第一个数和最后一个数相等，同时又存在满足条件的三元组，但是输出却为空数组。因为**python中索引为负数是合法的**，无法通过编译来找出bug，所以写的时候要注意！
