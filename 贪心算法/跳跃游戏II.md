# 跳跃游戏

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。

##解题思路

求最优解通常就是使用动态规划或者贪心算法，如果对这道题使用动态规划，会发现得不到转移方程，所以考虑贪心算法。

### 方法一

因为要求的是到达最后一个位置的最少次数，那么可以考虑从最后一个位置反向推导，每次都求得能够到达当前位置的最远位置，一直到起始点为止。为了求最远位置，每次都从数组的起点开始遍历，遍历到第一个符合条件的位置即可。

这样的话，时间复杂度可以达到O(n^2)。

### 方法二

考虑一下正向贪心求解。

对于任意位置，只要该位置的元素大于1，如果把**它能跳到最远的位置设为跳跃端点**，那么在端点之前，跳跃位置就有好几个选择，其中能够跳的最远的那个位置就是我们所需要的**局部最优解**，因为**这个解覆盖了其它的解**，于是，这个位置就是我们的下一跳位置，而它能跳到的最远距离就是新的端点，所以在**比较过当前端点内的所有解，也就是遍历到当前端点之后，将端点更新。**

端点所代表的值就是我们所能到达的最远距离，只要**端点值大于等于终点位置**，此时的`steps`就是要求的最少跳跃次数。又因为只要遍历到了端点位置就会更新，所以我们只需要遍历到终点的前一位，这样就保证**更新后的端点一定会大于等于终点位置**。

具体的算法实现就是：

1. 设置初始端点为0，对数组进行遍历，
2. 比较当前点的最远距离与最优解，更新最优解（此处的最优解即下一跳位置）。
3. 遍历到端点后，更新端点为最优解的值，同时步数加一。

这样对数组进行一次遍历即可，复杂度降到了O(n)。

### 代码

```java
class Solution {
    public int jump(int[] nums) {
        int maxPosition = 0;
        int end = 0;
        int steps = 0;
        for(int i=0;i<nums.length-1;i++){
            maxPosition = Math.max(maxPosition,nums[i]+i);
            if(end==i){
                end = maxPosition;
                steps ++;
            }
        }
        return steps;
    }
}
```

