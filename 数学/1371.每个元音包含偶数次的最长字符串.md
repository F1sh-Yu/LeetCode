# 1371.每个元音包含偶数次的最长字符串

> 给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

## 解题思路

要找到题目要求的子数组，首先就要能够判断给定子串中的元音出现次数，可以维护一个数组`dp`来记录以索引`i`为结尾的子串中的元音出现次数，这些子串都是从索引0开始的，如果需要任意字符串，只需要用右端点`dp[j]`减去左端点`dp[i]`即可。这就运用了**前缀和**的思想。

在本题中，元音字母有五个，为了记录每一个元音的出现次数，就要将`dp`数组扩展为二维。在这种情况下，在遍历一次得到dp数组后，依然要对每个子串分别求元音出现次数，这样复杂度还是O(n2)。

对于每一个右端点`j`，它的元音最长字符串只有0或1个，即`i`最小的情况，可以维护一个哈希表来记录不同的`i`值，这样就需要找到`dp[j]`与`dp[i]`之间的对应关系，用于给`dp[i]`进行分类。

根据题目要求，我们知道`dp[j]`与`dp[i]`每一个元音的出现次数差值都是偶数，单凭这个没有办法将`dp[i]`的可能情况进行分类，还要继续往下推，可以想到`dp[i]`与`dp[j]`元音出现次数的**奇偶性是相同的**，用奇偶性进行分类的话，总共的可能性就有32种，这样，我们就可以记录每一种情况最早出现的`dp[i]`。

问题到这里就解决了，我们遍历字符串，首先根据当前值更新`dp[j]`，同时查阅哈希表中与`dp[j]`同类的`dp[i]`是否存在，如果存在，该子字符串就符合条件，与`ans`进行比较；如果不存在，那么就将当前`dp[j]`存入哈希表中。

**再优化：**

按照上述的方法，哈希表中存储的键值对是{数组，位置`i`}的形式，相当的不好。考虑到**奇偶性的二值性**，用一个5位二进制数来保存元音出现次数的奇偶性即可。

因为属性就转化为了一个整数，就可以直接使用数组进行保存，而不再需要哈希表。

## 代码

```java
class Solution {
    public int findTheLongestSubstring(String s) {
        int n = s.length();
        int[] pos = new int[1 << 5];
        Arrays.fill(pos, -1);
        int ans = 0, status = 0;
        pos[0] = 0;
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (ch == 'a') {
                status ^= (1 << 0);
            } else if (ch == 'e') {
                status ^= (1 << 1);
            } else if (ch == 'i') {
                status ^= (1 << 2);
            } else if (ch == 'o') {
                status ^= (1 << 3);
            } else if (ch == 'u') {
                status ^= (1 << 4);
            }
            if (pos[status] >= 0) {
                ans = Math.max(ans, i + 1 - pos[status]);
            } else {
                pos[status] = i + 1;
            }
        }
        return ans;
    }
}
```

**注意点：**

代码中对于`pos`数组初始值给了`-1`而不是`0`，因为`pos`数组代表的是第一次出现的`status`，在初始值被更新之前是不会被使用的，按理来说设为`-1`还是`0`区别不大。但要注意到一种情况，假设初始值为`0`，那么判断条件就设为`if (pos[status] > 0)`，当字符串的索引，也就是`i`为`0`时，如果`s[0]`是元音，会更新`pos`数组，没有什么影响。但如果`s[0]`不是元音，就应该记录下当前子字符串，因为`pos[status]`初始值为0，不满足条件，那么就会记录下此时的`status`为0，记录的值为`i+1=1`。

问题就出现了，为什么在函数中每次更新`pos[status]`的值为`i+1`，因为`s[i]`一定是元音，为了求满足条件的子字符串，应该连同它左侧的字符串一起被去掉，把`i+1`作为起点。这样的做法根据上面的情况会使得`s[0]`失去作为子串起点的可能性。

所以把初始值设为`-1`，对后续没有影响，但是可以将判断条件改为`if(pos[status]>=0)`，再将`pos[0]`设为`0`即可。