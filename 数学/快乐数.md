# 快乐数

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
>
> 如果 n 是快乐数就返回 True ；不是，则返回 False 。

##解题思路

如果是快乐数，判断就非常的简单，只需要不断的循环计算，最后得到1即可，但是对于非快乐数，就会处于无限循环的状态，需要设置一个判断标准，来确认是否已经进入了无限循环的状态。

在链表中，判断环的存在是看是否遍历到已经遍历过的结点，在这里也是如此。但首先要证明数值的变化只会在一个范围中出现，而不是无限的变大，否则就不会出现重复的结点了。

| Digits | Largest | Next |
| ------ | ------- | ---- |
| 1      | 9       | 81   |
| 2      | 99      | 162  |
| 3      | 999     | 243  |
| 4      | 9999    | 324  |

由上述的表可以看出，对于三位数的数字，它的后续结果始终在243以下，（243的`next`必然比999的`next`要小），那么最多循环243次，就会出现重复，而对于四位数以上的数字，位数也会不断下降，最终降回到三位数，进入循环，因此无需担心无限变大的情况出现。

接下来就只需要考虑如何判断重复，在这里使用一个`Set`来记录已出现过的数字，如果出现重复的数字或出现了`1`就退出循环，返回`n==1`的结果。

## 代码

```java
class Solution {
    public int getNext(int n){
        int next = 0;
        while(n>0){
            next += (n % 10) * (n % 10);
            n = n/10;
        }
        return next;
    }
    public boolean isHappy(int n) {
        Set <Integer> seen = new HashSet<>();
        while(n!=1 && !seen.contains(n)){
            seen.add(n);
            n = getNext(n);
        }
        return n==1;
    }
}
```

