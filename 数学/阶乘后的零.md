# 阶乘后的零

> 给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

最简单的办法当然是按题目先求出*n*!，再循环求10的余数即可，这种方法递归深度可能过大，于是需要找规律来简化算法。

首先分析出，零的数量增加是因为阶乘中出现了10的倍数，可以分为两种情况，一种是阶乘中某个数本身就是10的倍数，另一种就是5的奇数倍数乘以任意偶数得到10的倍数，因为任意偶数是可以从阶乘中其他的数中得到的，且个数一定比5多，所以**只需要找5的个数即可**。如果把第一种情况看成是 *5x2*，那么就可以归纳为一种情况，即寻找5的倍数出现的次数，也就是 *n/5*。

但还要考虑到如 *25 = 5x5*，可以给结果贡献两个0，所以我们还应当加上额外的一个0，即 *n/25*。同理还有125，725……所以每加一次，都将n除以5，循环求解即可。

代码如下：

```java
class Solution {
    public int trailingZeroes(int n) {
        int count=0;
        while(n>0){
            count += n/5;
            n = n/5;
        }
        return count;
    }
}
```







