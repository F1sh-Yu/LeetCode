# 二叉树中的最大路径和

难度：**困难**

> 给定一个**非空**二叉树，返回其最大路径和。
>
> 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

## 解题思路

首先要考虑路径是如何扩展的，给定一条路径和一个节点，只要加上这个节点后，总路径和不小于0，就可以将其加入路径中。因为最大路径和可能出现在加入某一个节点之后，而非最终结果，所以每加入一个新节点都要更新最大路径和。

采用分治法的思想，每个节点都能得到它左右节点传来的路径和，如果值大于零，就把它加入到本节点的路径中，如果小于零则抛弃，这样就得到了**本节点与子树构成的最大路径和**，同时**更新一次全局的最大路径和**，然后将该值传向父节点，父节点同样选择加入或抛弃，依次向上传递即可。

要注意的是，向上传递之后，相当于本节点要与父节点相连，那么**与左右子节点的连接只能保留一个**，所以挑选其中的较大值保留，若二者均为负值，那么都抛弃。

所以采用递归算法：

- 递归左右子树，直到当前结点为空，返回0
- 得到左右子结点的返回值，如果小于0，则抛弃，如果大于0，则与本节点的权值`value`相加，得到一个`res`
- 将`res`与当前最大路径和进行比较并更新
- 返回`value`与左右节点返回值中的较大值的和，若左右节点返回值均为负值，则返回value

## 代码

```java
class Solution {
    int ans = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        helper(root);
        return ans;
    }

    public int helper(TreeNode root){
        if(root==null)return 0;
      //负值均抛弃
        int left = Math.max(helper(root.left),0);
        int right = Math.max(helper(root.right),0);
        ans = Math.max(root.val+left+right,ans);
        return root.val+Math.max(left,right);
    };
}
```



