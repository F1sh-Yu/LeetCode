# 字符串的最大公因子
> 对于字符串`S` 和`T`，只有在` S = T + ... + T`（`T`与自身连接 1 次或多次）时，我们才认定“`T`能除尽 S”。  
>   
> 返回最长字符串`X`，要求满足`X `能除尽 `str1 `且`X `能除尽 `str2`。  

## 枚举
最容易想到的还是枚举法，直接对`str1`和`str2`的每一个字串进行判断是否能除尽，就得到了
```
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        len1 = len(str1)
        len2 = len(str2)
        x = ‘’
        def divide(str,sub):
            if str.count(sub) == len(str)/len(sub):
                return True
        for i in range(min(len1,len2)):
            sub = str1[:i+1]
            if divide(str1,sub) and divide(str2,sub):
                x = sub
        return x
```
这个代码写的相当粗糙，有两个点是可以进行优化的：
1. 求的是字符串的公因子，则长度也应该是两个字符串长度的公约数，所以在for循环里面可以加个**判断语句**，跳过非公约数的长度。
2. 因为求的是最大公因子，那么可以将搜索顺序设置为逆序，这样只要找到第一个匹配的字串，就直接返回。

## 枚举优化
首先，根据上文，我们只会在**公约数长度的字串里面寻找最大公因子**，假设我们找到的`X`不是最大公约数，那么因为**最大公约数是任一公约数的倍数（数学定理）**，既然`X`可以除尽两个字符串，那么这个最大公约数长度的子串就是由n个`X`组成的，同样也可以除尽两个字符串。
所以我们只需要判断最大公约数长度的子串能不能除尽两个字符串即可。
但其实，这一想法，和我们上述优化后的代码是一样的，因为逆序搜索并且跳过非公约数长度，第一个就是我们所要判断的最大公因子。

## 数学
第三种方法，如果`str1`+`str2`等于`str2`+`str1`（数学原理），那么必然存在最大公因子，这时根据枚举优化中的结论直接求出最大公因子就可以了。