# 无重复字符的最长字串
> 给定一个字符串，请你找出其中不含有重复字符的 **最长子串**的长度。  

这道题有点类似于KMP算法，但KMP是将子串与另一字符串比较，而这里是要观察下一字符是否在子串中。如果用`list`存储子串，并且遍历判断下一字符是否在其中，复杂度就过高了，所以我们可以使用python中的`set`结构（JAVA中为`hashset`），**仅需要O(1)的复杂度就可以判断子串中是否包含特定字符**。
`set`可以视为一个**滑动窗口**，如果下一字符与`set`中重复了，那么`set`就删去最左端的元素，再进行一次判断，直到重复字符被删去，这时再将右侧的新字符加入`set`之中。
要注意的是，`set`是一种哈希结构，字符是以关键字的形式存储的，不存在`index`，所以我们要给一个变量，记录子串最左端的`index`，从原来的字符串中提取出对应字符，再从`set`中删去，同时变量加一。
具体算法：

1. 定义变量`left`，`max_len`
2. 对字符串进行遍历，若当前字符在`set`中，则从`set`中删除`s[left]`，重新进行判断。若字符不在`set`中，则将该字符加入。
3. 比较`max_len`与`i-left+1`的大小，更新`max_len`，回到2继续遍历。
4. 输出`max_len`

	在上述方法中，在更新滑动窗口的过程中是从最左端一步步往右寻找重复字符串的，所以要想办法优化，一步到位找到重复的那个字符，那么就需要字符的`index`，所以我们使用`dict`结构，既可以在O(1)的复杂度内判断子串是否含有重复字符，同时还能调出相对应的`index`值。
	要注意的是，在`dict`中记录的是重复字符上一次出现的位置，也有可能已经不在子串里了，所以我们依然要记录子串最左端的`index`，判断该重复字符是否在子串中。
	代码如下：
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        map = {}
        max_len = 0
        left = 0
        for index,i in enumerate(s):
            if i in map:
                left = max(left,map[i])
            max_len = max(max_len, index - left + 1)
            map[i] = index + 1
        return max_len
```

