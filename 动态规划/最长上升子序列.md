# 最长上升子序列
> 给定一个无序的整数数组，找到其中最长上升子序列的长度。  
> **示例:**  
> **输入:** [10,9,2,5,3,7,101,18]  
> **输出:**4   
> **解释:**最长的上升子序列是 [2,3,7,101]，它的长度是 4。  

本题的特征是 **求最优子结构，问题可以被分解成子问题解决**，即不断将给定序列分解为子序列，再求最长上升序列，面对这种问题，我们就可以采用**动态规划**方法，减少重复计算量。
因为只需要输出最长上升序列的长度，不需要输出具体字符串，所以我们用一个`list:dp[]`来记录即可。`list`中的第n项表示从头开始，长度为n的子序列所拥有的最长上升子序列的长度。
对于序列中第n个值，将它与它前面n-1个值进行比较，记录下比它小的所有值中`dp[i]`最大的那一个，加上1，就是`dp[n]`。
得到代码如下：

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

通常能够用动态规划的题目，也可以使用贪心算法。
我们同样需要一个额外的`list`来做记录，但这次`d[i]`表示任意长度为i的子序列中最后一项的最小值。
具体算法：
对序列中的每一个值进行遍历，先将它与`d[]`的最后一个元素比较（所以我们用一个`len`来记录当前`d[]`最后一个元素的index），如果当前值大于`d[len]`，则更新`d[len+1]`为当前值，并且`len`加一。否则就在`d[]`中寻找满足条件的`d[i]和d[i+1]`，使得当前值大于`d[i]`并小于`d[i+1]`，将`d[i+1]`更新为当前遍历值。为了提升效率，在`d[]`中采用**二分查找**的方法。