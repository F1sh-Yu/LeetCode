# 硬币

> 给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

其实这道题就是斐波那契数列的复杂版本，可以看成$$f(n)=f(n-25)+f(n-10)+f(n-5)+f(n-1)$$，但是如果用递归，这道题的复杂度就会过高，因此采用动态规划的方法。

转换方程就是$$f(x) = f(x)+f(x-coin)$$，因为`coin`的值有四种情况，所以f(x)要加上自身，完成四种情况的叠加。所以，总的算法有两层循环，一层是对于`coin`的遍历，一层是对于`dp`数组的遍历，如果`dp`数组遍历在外层，拿`dp[6]`举例，它会加上`dp[1]`和`dp[5]`的值，但其实（1，5）和（5，1）是相同的情况，为了避免这种重复，要将`coin`的遍历放在外层。

`dp`数组的初始值`dp[0]`应当设为1，这是因为`dp[0]`是`x-coin=0`的情况，也就是只需要一枚硬币，所以值为1。

代码如下：

```java
class Solution {
    public int waysToChange(int n) {
        int[] dp = new int[n+1];
        int[] coins = new int[]{1,5,10,25};
        dp[0] = 1;
        for(int coin:coins){
            for(int i=coin;i<=n;i++)
                dp[i] = (dp[i] + dp[i-coin]) % 1000000007;
        }
        return dp[n];
    }
}
```

