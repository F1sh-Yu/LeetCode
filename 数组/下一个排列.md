#下一个排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须原地修改，只允许使用额外常数空间。
>
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> 1,2,3 → 1,3,2
> 3,2,1 → 1,2,3
> 1,1,5 → 1,5,1

## 解题思路

首先要理解什么是字典序，就是把给定数字序列中进行**全排列**得到一个字典，并且字典中排列的顺序是从小到大（按位依次比较），如果把数字序列看成一个数，即**下一个排列要比当前排列大，且数值的变化最小**，在接下来的算法实现中，始终遵循这两个原则。

那么如何得到下一个排列呢？首先必须保证有一位数字是增大的，并且它前面的数字不能改变，同时它后面的数字要保持一个最小排列（即有序排列），这样才能保证变化是最小的。

关键就在于如何寻找这一位数字，首先因为要对它增大，在整个数字序列给定的情况下，前面的数字不能改变，那么就只能从它的后面找数字，所以从序列的末尾往前找，找到第一个比它后面数字小的数字即可。其次为了使数值的变化最小，选择它后面**所有比它大的数字中最小的那一个**，进行交换，此时数字序列已然增大，再将后面的序列进行一个排序即可。

对于特殊情况，即不存在更大的排列，我们就无需交换，直接对整个数组进行排序，得到一个最小序列即可。

## 代码

```java
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length<2)return;
        int i = nums.length-2;
        while(i>=0 && nums[i]>=nums[i+1]){
            i--;
        }
        int k = i+1;
        if(i>=0){
            for(int j=i+1;j<nums.length;j++){
            if(nums[j]>nums[i] && nums[j]<=nums[k])k = j;
            }
            int temp = nums[i];
            nums[i] = nums[k];
            nums[k] = temp;
        }
        Arrays.sort(nums,i+1,nums.length);
        return;
    }
}
```

